# Wil-YAT
Comparison of Wilson and Yates Headwords

## Synopsis
In the [preface](http://www.sanskrit-lexicon.uni-koeln.de/scans/csldoc/dictionaries/prefaces/yatpref/yatpref02.html) to
the Yates dictionary, the author asserts his work to be closely based on the Wilson dictionary.  Informal comparison of 
first couple of pages of the two dictionaries confirms that the headwords of the two dictionaries are nearly identical. 

The current focus of my work and of the work of others here at the 
[Sanskrit Lexicon](https://github.com/sanskrit-lexicon/) has been the correction of spelling errors in the 
Cologne digitizations, and more specifically on the correction of headword spelling errors.  In addition to the
occasional corrections from various users of the dictionary, there have been systematic approaches to identifying
such spelling errors.  Thus far, the two most productive techniques for identifying spelling error candidates 
are the [faultfinder](https://github.com/funderburkjim/SanskritSpellCheck) approach developed by Dhaval 
Patel and the alphabetical misordering approach.   Briefly, the faultfinder approach generates many fragments of 
headword spellings that occur in a `reference` dictionary (often, Monier-Williams 1899) and generates similar
fragments for each headword in a `test` dictionary.  When a `test` headword has a fragment that does not occur in the
`reference`, then that headword is marked as a candidate that may be misspelled, and is further examined by hand.
The alphabetical misordering approach is applicable to those dictionaries which list headwords (at least usually) in 
Sanskrit alphabetical order. When the digitized list of headwords for such a dictionary shows a pair of words that are
*not* in proper alphabetical order, the words are considered candidates for further examination regarding the correctness
of their spelling.

The present study also has as its primary focus the identification of headword spelling errors for the Wilson and Yates
dictionaries. The approach uses the similarity of the headword lists and generally identifies candidates that are not
identified by the faultfinder approach.  Thus far, approximately 400 corrections to Wilson headword spellings have been
generated by this comparison approach, and about 800 corrections to Yates headword spellings.  The task remains 
incomplete, although it is believed that the work remaining to complete this approach is considerably less than what
has been done.  In the last `TODO` section, specific suggestions for further work are given.  
It is also believed that a similar comparison between the Shabda-Sagara and Wilson-Yates dictionaries will be productive in
identifying headword spelling errors in Shabda-Sagara.

## Inputs to the comparison
This study is heavily assisted by custom computer programs.  These programs use certain specific forms of the Cologne
digitizations of Wilson and Yates dictionairies.  Current versions are in the `data` subdirectory of this repository.

* wil.txt  is the Cologne digitization of the Wilson dictionary. It was drawn from the 'wiltxt.zip' download 
   [here](http://www.sanskrit-lexicon.uni-koeln.de/scans/WILScan/2014/web/webtc/download.html).
* wilhw2.txt is the list of headwords derived from wil.txt.  It is in the 'wilxml.zip' download.
* yat.txt  is the Cologne digitization of the Yates dictionary. It was drawn from the 'yattxt.zip' download
   [here](http://www.sanskrit-lexicon.uni-koeln.de/scans/YATScan/2014/web/webtc/download.html).
* yathw2.txt is the list of headwords derived from yat.txt.  It is in the 'yatxml.zip' download.
* wil_mw.txt  This file has most of the Wilson headwords which are roots; it also has a correspondence to
  headwords of roots in Monier-Williams, but this correspondence is not used in the present work.  It was drawn  
  from [here](https://github.com/sanskrit-lexicon/WIL/blob/master/wilmwroots/step2/wil_mw.txt).
  
## Outputs of the comparison, and workflow
The comparison of the Wilson and Yates headwords is done in stages.
* hwcmp.txt  is the first approximation of the correspondence between the two headword lists. It is done by the
  program
  ```
   python hwcmp.py data/wilhw2.txt data/yathw2.txt force.txt hwcmp.txt
  ```
  The file 'force.txt' is an input, as well as the two lists of headwords.  This input file is created by
  hand to `force` the correspondence between certain headwords, and is needed to handle cases that are too
  subtle to handle by the more general algorithm of hwcmp.
  
  Each line of hwcmp.txt represents a comparison between 1 or more headword records from wilhw2.txt and yathw2.txt,
  and has the general form `<wilson> <reason> <yates>`. For instance `aMSaka:33,35 == aMSaka:98,99` indicates that
  the headword aMSaka occurring in the Wilson digitization on lines 33-35 corresponds (with reason code `==`) to 
  the headword aMSaka occurring in the Yates digitization on lines 98,99. A slight variation of this form is
  illustrated by the comparison `a:7,8;a:9,15 == a:85,92` which indicates that the two headword entries for 
  headword `a` in Wilson (one on lines 7,8 and the other on lines 9,15) correspond to the single headword entry
  `a` in Yates on lines 85,92;  in other words, Yates combines two Wilson entries.  This example is the first
  use of the force.txt file, as the hwcmp.py program cannot make such a subtle comparison, so it was necessary to
  force the comparison here.
  
  The `<reason>` code is used to classify the nature of the correspondence.  The hwcmp.py program itself only
  assigns one of three reason codes :
   * `==`  means the corresponding Wilson and Yates headwords are identically spelled.
    This is by far the most common case (40000 out of 47000 comparison in hwcmp.txt).
   * `~=`  means the headwords are spelled *almost* identically (edit distance of 1 between the two spellings)
   * `NONE` means that the program believes that a headword appears only in Wilson
     (example `afRin:18,21 NONE MISSING`) or only in Yates (example `MISSING NONE aMSumatI:120,121`).
     
  Later steps will introduce several other programmatically assigned reason codes. 
  
* hwcmp_near.txt is an extraction of the cases in hwcmp.txt where the correspondence is an approximate match

  ```
  python hwnear_init.py hwcmp.txt hwcmp_near.txt
  ```
  This is a simple convenience step; no analysis is performed here.
  
* hwcmp_near_analyze.txt classifies the approximate matches into various categories

  ```
  python analyze_near.py hwcmp_near.txt hwcmp_near_analyze.txt data/wil_mw.txt
  ```
  This step refines the analysis of the approximate matches.  The approximate match reason is sub-categorized
  based on several systematic differences between the spelling conventions of Wilson and Yates. Here are the
  categories currently:
  * `=V` This means that the headwords in question are roots, which Wilson and Yates spell slightly differently.
    Typically, the Wilson spelling ends in 'a' and the Yates spelling drops that final 'a'.  This is where the
    wil_mw.txt file is used, in order to determine that the Wilson headword is indeed marked as a root in Wilson.
  * `=vb` Here, Wilson spells a word with a 'v' and Yates with a 'b', or vice-versa.  Possibly, some of these
    should be treated as spelling errors in one or the other dictionary; however, there are many 'alternate' 
    spellings, and it is currently deemed too difficult to decide whether one of the spellings is in error.
  * `=rxx` Here, one of the dictionaries doubles a consonant after an 'r', and the other one does not.  It is
    believed that both spellings are correct.
  * `=cC` One of the dictionaries has a spelling of 'cC', and the other of 'C' It is believed that both spellings
    are correct.
  * `=tt` One of the dictionaries uses 'tt' and the other 't'; *probably* both spellings are correct.
  * `=nasal` Example `apANkta:9011,9017 =nasal apAMkta:2798,2799`.  It is believed that both spellings are correct.
  * `=mM$`  Example `ayaTAbalam:12648,12650 =mM$ ayaTAbalaM:3830,3830`. It is believed that both spellings are correct.
  * `=aA` Example `kaSeruka:40939,40942 =aA kaSerukA:13055,13055`. In this example, Wilson shows multiple genders
    while Yates just shows the feminine form; it is thought useful to consider the two entries to correspond. 
    *All these cases should be examined to ensure they are like the example.*
  * `=sH` Example `kAmakAratas:42044,42047 =sH$ kAmakArataH:13452,13452`  Probably both spellings are correct.
  * `=a` This is a small list (4), where one spelling adds a final 'a' to the other.  *These should be re-examined.*
  * *~=* None of the systematic correspondences apply. The two headwords are spelled similarly. Maybe one is
    misspelled, or maybe there is some reasonable infrequent systematic spelling difference. *These need to be
    examined further.*

* hwcmp_adj.txt installs the correspondences of hwcmp_near_analyze.txt into hwcmp.txt, and does some further
  multi-record adjustments.  It may be viewed as the final output of the comparison process.
  
  ```
  python hwcmp_adj.py hwcmp.txt hwcmp_near_analyze.txt hwcmp_adj.txt
  ```
  The additional analysis is currently of just one form. An example will show the adjustment:
  ```
  Example: BEFORE
  MISSING NONE lAj:48823,48824
  lAja:141031,141034 == lAja:48825,48827
  lAja:141035,141038 NONE MISSING

  AFTER
  MISSING NONE MISSING
  lAja:141031,141034 =V* lAj:48823,48824
  lAja:141035,141038 == lAja:48825,48827
  ```
  In this case, the first Wilson `lAja` is a root, and corresponds to the Yates spelling `lAj`; while the
  second Wilson `lAja` is a substantive, and is spelled the same by Yates.  These are marked `=V*` instead of
  `=V` just to identify the cases.  There are cases, such as
  ```
  akza:491,495 =V akz:221,222;akz:223,223
  akza:496,517 == akza:224,225
  ```
  where prior analysis (or force.txt) already made the correspondence. 
  
## Corrections
The present state of the inputs (wilhw2.txt, yathw2.txt, etc) reflect corrections that were discovered by
examining the `~=` cases of hwcmp_near_analyze.txt based on these inputs before corrections.
The corrections so discovered are present in the wil_corr.txt and yat_corr.txt files.
Here is a sample correction, as it appears in wil_corr.txt:
```
; 03/06/2015 sudusmaha -> sudussaha (typo, m/s confusion)
182108 old .{#sudusmaha#}¦ mfn. ({#-haH-hA-haM#}) Very difficult to be endured.
182108 new .{#sudussaha#}¦ mfn. ({#-haH-hA-haM#}) Very difficult to be endured.
182109 old .E. {#su#} very, {#dusmaha#} unendurable.
182109 new .E. {#su#} very, {#dussaha#} unendurable.
```
The first line shows the date, the correction, and a parenthetical comment based on examination of the
scanned image for this case. The corrections in Wilson were generally typos (errors in digitization) while the
corrections in Yates were generally print errors (errors in the scanned image).

In the example, a secondary correction (dusmaha -> dussaha) was also noticed.

The dump_cases.py program was used to generate output to make more efficient the manual workflow of 
constructing wil_corr.txt and yat_corr.txt. For instance, a batch of about 40 of the `~=` cases in
hwcmp_near_analyze.txt was offloaded to a temporary file `scratch/temp.txt` and then a file 
`scratch/temp_dump.txt` was created:
```
python dump_cases.py scratch/temp.txt scratch/temp_dump.txt data/wil.txt data/yat.txt data/wilhw2.txt data/yathw2.txt
```
Here is a sample of temp_dump.txt:
```
case 020: svargOkas:188687,188689 ~= svargIkas:67405,67405
data/wil.txt (page 963)
; 03/09/2015 svargOkas -> svargIkas ()
188687 old .{#svargOkas#}¦ m. ({#-kAH#}) A god, a deity.
188687 new .{#svargIkas#}¦ m. ({#-kAH#}) A god, a deity.
188688 old .E. {#svarga#} paradise, and {#okas#} abode.
188689 old 

data/yat.txt (page 887-b)
; 03/09/2015 svargIkas -> svargOkas (print error)
067405 old <HI>{#svargI\kas (kAH)#}¦ 5. {%m.%} A god, a deity.
067405 new <HI>{#svargI\kas (kAH)#}¦ 5. {%m.%} A god, a deity.

```
From this, we clearly see that the two words correspond, and from Wilson's etymology it is likely that
yat.txt needs correcting.
Sometimes the multidictionary lookup [hwnorm1](http://www.sanskrit-lexicon.uni-koeln.de/scans/awork/hwnorm/hwnorm1.php),
is useful for confirming a suspicion.
So, the Yates spelling is considered an error, and add the following correction to yat_corr.txt
```
; 03/09/2015 svargIkas -> svargOkas (print error)
067405 old <HI>{#svargI\kas (kAH)#}¦ 5. {%m.%} A god, a deity.
067405 new <HI>{#svargO\kas (kAH)#}¦ 5. {%m.%} A god, a deity.
```
Note:  In reviewing this while writing this note, I would now classify this as a typo, rather than a print error.

So, that describes the workflow for the corrections made so far.

## Summary of hwcmp_adj.txt categories
As of this writing, here are the frequency of occurrence of the `<reason>` categories from hwcmp_adj.txt:

|reason|:count|
|------|------:|
|==|40668|
|NONE|4616|
|=V|743|
|=V*|299|
|~=|126|
|=vb|110|
|=rxx|82|
|=aA|40|
|=tt|33|
|=nasal|30|
|=cC|23|
|=?|11|
|=mM$|7|
|=sH$|7|
|=a|4|

## TODO 
Here are some suggestions of where improvements can be made.

* Independent review of yat_corr.txt and wil_corr.txt would likely turn up a few places where my solution was
  in error.  Hopefully, most corrections are 'correct'.
* Systematic evaluation of subcases hwcmp_adj.txt will turn up additional corrections and/or correspondences.
  For instance:
  * Some of  `~=` will be due to spelling errors.  For instance, I notice that 
    ```
    sEnDavaGana:184781,184783 ~= sEnDavaDana:65847,65847
    ```
  is a correction to Yates that was missed.
  * Some of the other correspondences should perhaps be relabled, such as
  
    ```
    ambuvAhin:12419,12422 ~= ambuvAhinI:3757,3758
    ```
    where Yates shows only the feminine form.
  * Probably force.txt should be modified so agnideva and agnidevA correspond (here's the hwcmp.txt sequence):
  
    ```
    agnideva:1105,1110 NONE MISSING
    MISSING NONE agnidUzita:439,439
    agnidEvatya:1111,1113 NONE MISSING
    MISSING NONE agnidevA:440,440
    ```
  * Several sequences involving verbs need manual correspondence via force.txt. For example:
  
    ```
    MISSING NONE ag:348,348
    aga:833,835 == aga:349,350
    aga:836,844 == aga:351,352
    ```
  
If anyone else wants to help in these tasks, I might be able to help in developing some displays, such as
modifications of dump_cases.py.  Just mention this in an issue if you are interested.

If no one helps, I'll probably reexamine these and other similar cases at some time in the future.

As mentioned above, a similar comparison with the Sabda-sagara dictionary, which is also closely based on Wilson,
would likely turn up numerous corrections to the SHS headwords.

